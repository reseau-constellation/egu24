import{C as m,i as L,m as _,h as $,f as M,j as V,T as U,n as S,t as G,A as C,k as F}from"./index-D4A2jxKK.js";import{o as O}from"./os-CUlhgMAr.js";const D=421,H=290,z=400,B=500,K=5*6e4,T={ERR_INVALID_IP_PARAMETER:"ERR_INVALID_IP_PARAMETER",ERR_INVALID_PORT_PARAMETER:"ERR_INVALID_PORT_PARAMETER",ERR_INVALID_IP:"ERR_INVALID_IP"};function W(r,e){if(typeof r!="string")throw new m(`invalid ip provided: ${r}`,T.ERR_INVALID_IP_PARAMETER);if(typeof e=="string"&&(e=parseInt(e)),isNaN(e))throw new m(`invalid port provided: ${e}`,T.ERR_INVALID_PORT_PARAMETER);if(L(r))return _(`/ip4/${r}/tcp/${e}`);if($(r))return _(`/ip6/${r}/tcp/${e}`);throw new m(`invalid ip:port for creating a multiaddr: ${r}:${e}`,T.ERR_INVALID_IP)}var y={exports:{}},w=r=>{if(r[Symbol.asyncIterator])return r;if(r.getReader)return async function*(){const e=r.getReader();try{for(;;){const{done:t,value:n}=await e.read();if(t)return;yield n}}finally{e.releaseLock()}}();throw new Error("unknown stream")},X=function(e){if(e){if(typeof e[Symbol.iterator]=="function")return e[Symbol.iterator]();if(typeof e[Symbol.asyncIterator]=="function")return e[Symbol.asyncIterator]();if(typeof e.next=="function")return e}throw new Error("argument is not an iterator or iterable")};const Y=X;var N=r=>async e=>{e=Y(e);const t=l=>{typeof l.return=="function"&&l.return()};let n=null,s=null;const d=l=>{n=l,s&&s(l),t(e)};let u=null,i=!1;const g=()=>{i=!0,u&&u()};let a=null,p=!1;const E=()=>{p=!0,a&&a()};let h=null;const o=()=>{h&&h()},f=()=>new Promise((l,A)=>{u=h=l,s=A,r.once("drain",o)}),v=()=>(t(e),new Promise((l,A)=>{if(i||p||n)return l();a=u=l,s=A})),I=()=>{r.removeListener("error",d),r.removeListener("close",g),r.removeListener("finish",E),r.removeListener("drain",o)};r.once("error",d),r.once("close",g),r.once("finish",E);try{for await(const l of e){if(!r.writable||r.destroyed||n)break;r.write(l)===!1&&await f()}}catch(l){n||r.destroy(),n=l}try{if(r.writable&&r.end(),await v(),n)throw n}finally{I()}};const q=N,J=w;var k=r=>({sink:q(r),source:J(r)});const Q=k;var Z=r=>async function*(e){const t=Q(r);let n;if(t.sink(e).catch(s=>{n=s}),yield*t.source,n)throw n};y.exports=w;y.exports.source=w;y.exports.sink=N;y.exports.transform=Z;y.exports.duplex=k;var j=y.exports;const ee=M(j),te={ip4:"IPv4",ip6:"IPv6"};function b(r,e={}){const t=r.getPath();return t!=null?O.platform()==="win32"?{path:V.join("\\\\.\\pipe\\",t)}:{path:t}:{...e,...r.toOptions()}}function R(r,e,t){const n=s=>_(`/${r}/${s}/tcp/${t}`);return(re(e)?se(te[r]):[e]).map(n)}function re(r){return["0.0.0.0","::"].includes(r)}const ne=O.networkInterfaces();function se(r){const e=[];for(const[,t]of Object.entries(ne))if(t!=null)for(const n of t)n.family===r&&e.push(n.address);return e}const x=(r,e)=>{const t=e.logger.forComponent("libp2p:tcp:socket"),n=e.metrics,s=e.metricPrefix??"",d=e.socketInactivityTimeout??K,u=e.socketCloseTimeout??B;e.listeningAddr?.getPath()!=null&&(e.remoteAddr=e.listeningAddr),e.remoteAddr?.getPath()!=null&&(e.localAddr=e.remoteAddr);let i;if(e.remoteAddr!=null)i=e.remoteAddr;else{if(r.remoteAddress==null||r.remotePort==null)throw new m("Could not determine remote address or port","ERR_NO_REMOTE_ADDRESS");i=W(r.remoteAddress,r.remotePort)}const g=b(i),a=g.path??`${g.host??""}:${g.port??""}`,{sink:p,source:E}=ee.duplex(r);r.setTimeout(d,()=>{t("%s socket read timeout",a),n?.increment({[`${s}timeout`]:!0});let o;r.readable&&(o=new m("Socket read timeout","ERR_SOCKET_READ_TIMEOUT")),r.destroy(o)}),r.once("close",()=>{t("%s socket close",a),n?.increment({[`${s}close`]:!0}),h.timeline.close==null&&(h.timeline.close=Date.now())}),r.once("end",()=>{t("%s socket end",a),n?.increment({[`${s}end`]:!0})});const h={async sink(o){try{await p(async function*(){for await(const f of o)f instanceof Uint8Array?yield f:yield f.subarray()}())}catch(f){f.type!=="aborted"&&t.error("%s error in sink",a,f)}r.end()},source:E,remoteAddr:i,timeline:{open:Date.now()},async close(o={}){if(r.destroyed){t("%s socket was already destroyed when trying to close",a);return}if(o.signal==null){const v=AbortSignal.timeout(u);o={...o,signal:v}}const f=()=>{r.destroy(new m("Destroying socket after timeout","ERR_CLOSE_TIMEOUT"))};o.signal?.addEventListener("abort",f);try{t("%s closing socket",a),await new Promise((v,I)=>{r.once("close",()=>{t("%s socket closed",a),v()}),r.once("error",l=>{t("%s socket error",a,l),h.timeline.close==null&&(h.timeline.close=Date.now()),I(l)}),r.setTimeout(u),r.end(),r.writableLength>0?r.once("drain",()=>{t("%s socket drained",a),r.destroy()}):r.destroy()})}catch(v){this.abort(v)}finally{o.signal?.removeEventListener("abort",f)}},abort:o=>{t("%s socket abort due to error",a,o),r.destroy(o),h.timeline.close==null&&(h.timeline.close=Date.now())},log:t};return h};async function P(r,e){try{await r.close()}catch(t){e.log.error("an error occurred closing the connection",t),r.abort(t)}}var c;(function(r){r[r.INACTIVE=0]="INACTIVE",r[r.ACTIVE=1]="ACTIVE",r[r.PAUSED=2]="PAUSED"})(c||(c={}));class oe extends U{context;server;connections=new Set;status={code:c.INACTIVE};metrics;addr;log;constructor(e){if(super(),this.context=e,e.keepAlive=e.keepAlive??!0,e.noDelay=e.noDelay??!0,this.log=e.logger.forComponent("libp2p:tcp:listener"),this.addr="unknown",this.server=S.createServer(e,this.onSocket.bind(this)),e.maxConnections!==void 0&&(this.server.maxConnections=e.maxConnections),e.closeServerOnMaxConnections!=null&&e.closeServerOnMaxConnections.closeAbove<e.closeServerOnMaxConnections.listenBelow)throw new m("closeAbove must be >= listenBelow","ERR_CONNECTION_LIMITS");this.server.on("listening",()=>{if(e.metrics!=null){const t=this.server.address();t==null?this.addr="unknown":typeof t=="string"?this.addr=t:this.addr=`${t.address}:${t.port}`,e.metrics?.registerMetricGroup("libp2p_tcp_inbound_connections_total",{label:"address",help:"Current active connections in TCP listener",calculate:()=>({[this.addr]:this.connections.size})}),this.metrics={status:e.metrics.registerMetricGroup("libp2p_tcp_listener_status_info",{label:"address",help:"Current status of the TCP listener socket"}),errors:e.metrics.registerMetricGroup("libp2p_tcp_listener_errors_total",{label:"address",help:"Total count of TCP listener errors by type"}),events:e.metrics.registerMetricGroup("libp2p_tcp_listener_events_total",{label:"address",help:"Total count of TCP listener events by type"})},this.metrics?.status.update({[this.addr]:c.ACTIVE})}this.safeDispatchEvent("listening")}).on("error",t=>{this.metrics?.errors.increment({[`${this.addr} listen_error`]:!0}),this.safeDispatchEvent("error",{detail:t})}).on("close",()=>{this.metrics?.status.update({[this.addr]:this.status.code}),this.status.code!==c.PAUSED&&this.safeDispatchEvent("close")})}onSocket(e){if(this.status.code!==c.ACTIVE)throw new m("Server is is not listening yet","ERR_SERVER_NOT_RUNNING");e.on("error",n=>{this.log("socket error",n),this.metrics?.events.increment({[`${this.addr} error`]:!0})});let t;try{t=x(e,{listeningAddr:this.status.listeningAddr,socketInactivityTimeout:this.context.socketInactivityTimeout,socketCloseTimeout:this.context.socketCloseTimeout,metrics:this.metrics?.events,metricPrefix:`${this.addr} `,logger:this.context.logger})}catch(n){this.log.error("inbound connection failed",n),this.metrics?.errors.increment({[`${this.addr} inbound_to_connection`]:!0});return}this.log("new inbound connection %s",t.remoteAddr);try{this.context.upgrader.upgradeInbound(t).then(n=>{this.log("inbound connection upgraded %s",t.remoteAddr),this.connections.add(t),e.once("close",()=>{this.connections.delete(t),this.context.closeServerOnMaxConnections!=null&&this.connections.size<this.context.closeServerOnMaxConnections.listenBelow&&this.resume().catch(s=>{this.log.error("error attempting to listen server once connection count under limit",s),this.context.closeServerOnMaxConnections?.onListenError?.(s)})}),this.context.handler!=null&&this.context.handler(n),this.context.closeServerOnMaxConnections!=null&&this.connections.size>=this.context.closeServerOnMaxConnections.closeAbove&&this.pause(!1).catch(s=>{this.log.error("error attempting to close server once connection count over limit",s)}),this.safeDispatchEvent("connection",{detail:n})}).catch(async n=>{this.log.error("inbound connection failed",n),this.metrics?.errors.increment({[`${this.addr} inbound_upgrade`]:!0}),await P(t,{log:this.log})}).catch(n=>{this.log.error("closing inbound connection failed",n)})}catch(n){this.log.error("inbound connection failed",n),P(t,{log:this.log}).catch(s=>{this.log.error("closing inbound connection failed",s),this.metrics?.errors.increment({[`${this.addr} inbound_closing_failed`]:!0})})}}getAddrs(){if(this.status.code===c.INACTIVE)return[];let e=[];const t=this.server.address(),{listeningAddr:n,peerId:s}=this.status;if(t==null)return[];if(typeof t=="string")e=[n];else try{n.toString().startsWith("/ip4")?e=e.concat(R("ip4",t.address,t.port)):t.family==="IPv6"&&(e=e.concat(R("ip6",t.address,t.port)))}catch(d){this.log.error("could not turn %s:%s into multiaddr",t.address,t.port,d)}return e.map(d=>s!=null?d.encapsulate(`/p2p/${s}`):d)}async listen(e){if(this.status.code===c.ACTIVE||this.status.code===c.PAUSED)throw new m("server is already listening","ERR_SERVER_ALREADY_LISTENING");const t=e.getPeerId(),n=t==null?e.decapsulateCode(D):e,{backlog:s}=this.context;try{this.status={code:c.ACTIVE,listeningAddr:n,peerId:t,netConfig:b(n,{backlog:s})},await this.resume()}catch(d){throw this.status={code:c.INACTIVE},d}}async close(){const e=new m("Listener is closing","ERR_LISTENER_CLOSING");this.connections.forEach(t=>{t.abort(e)}),await this.pause(!0)}async resume(){if(this.server.listening||this.status.code===c.INACTIVE)return;const e=this.status.netConfig;await new Promise((t,n)=>{this.server.once("error",n),this.server.listen(e,t)}),this.status={...this.status,code:c.ACTIVE},this.log("listening on %s",this.server.address())}async pause(e){if(!this.server.listening&&this.status.code===c.PAUSED&&e){this.status={code:c.INACTIVE};return}!this.server.listening||this.status.code!==c.ACTIVE||(this.log("closing server on %s",this.server.address()),this.status=e?{code:c.INACTIVE}:{...this.status,code:c.PAUSED},await new Promise((t,n)=>{this.server.close(s=>{if(s!=null){n(s);return}t()})}))}}class ie{opts;metrics;components;log;constructor(e,t={}){this.log=e.logger.forComponent("libp2p:tcp"),this.opts=t,this.components=e,e.metrics!=null&&(this.metrics={dialerEvents:e.metrics.registerCounterGroup("libp2p_tcp_dialer_events_total",{label:"event",help:"Total count of TCP dialer events by type"})})}[G]=!0;[Symbol.toStringTag]="@libp2p/tcp";async dial(e,t){t.keepAlive=t.keepAlive??!0,t.noDelay=t.noDelay??!0;const n=await this._connect(e,t);n.on("error",i=>{this.log("socket error",i)});const s=x(n,{remoteAddr:e,socketInactivityTimeout:this.opts.outboundSocketInactivityTimeout,socketCloseTimeout:this.opts.socketCloseTimeout,metrics:this.metrics?.dialerEvents,logger:this.components.logger}),d=()=>{s.close().catch(i=>{this.log.error("Error closing maConn after abort",i)})};t.signal?.addEventListener("abort",d,{once:!0}),this.log("new outbound connection %s",s.remoteAddr);const u=await t.upgrader.upgradeOutbound(s);if(this.log("outbound connection %s upgraded",s.remoteAddr),t.signal?.removeEventListener("abort",d),t.signal?.aborted===!0)throw u.close().catch(i=>{this.log.error("Error closing conn after abort",i)}),new C;return u}async _connect(e,t){if(t.signal?.aborted===!0)throw new C;return new Promise((n,s)=>{const d=Date.now(),u=b(e,{...this.opts.dialOpts??{},...t});this.log("dialing %a",e);const i=S.connect(u),g=o=>{const f=u.path??`${u.host??""}:${u.port}`;o.message=`connection error ${f}: ${o.message}`,this.metrics?.dialerEvents.increment({error:!0}),h(o)},a=()=>{this.log("connection timeout %a",e),this.metrics?.dialerEvents.increment({timeout:!0});const o=new m(`connection timeout after ${Date.now()-d}ms`,"ERR_CONNECT_TIMEOUT");i.emit("error",o)},p=()=>{this.log("connection opened %a",e),this.metrics?.dialerEvents.increment({connect:!0}),h()},E=()=>{this.log("connection aborted %a",e),this.metrics?.dialerEvents.increment({abort:!0}),i.destroy(),h(new C)},h=o=>{if(i.removeListener("error",g),i.removeListener("timeout",a),i.removeListener("connect",p),t.signal!=null&&t.signal.removeEventListener("abort",E),o!=null){s(o);return}n(i)};i.on("error",g),i.on("timeout",a),i.on("connect",p),t.signal!=null&&t.signal.addEventListener("abort",E)})}createListener(e){return new oe({...this.opts.listenOpts??{},...e,maxConnections:this.opts.maxConnections,backlog:this.opts.backlog,closeServerOnMaxConnections:this.opts.closeServerOnMaxConnections,socketInactivityTimeout:this.opts.inboundSocketInactivityTimeout,socketCloseTimeout:this.opts.socketCloseTimeout,metrics:this.components.metrics,logger:this.components.logger})}filter(e){return e=Array.isArray(e)?e:[e],e.filter(t=>t.protoCodes().includes(H)?!1:t.protoCodes().includes(z)?!0:F.matches(t.decapsulateCode(D)))}}function le(r={}){return e=>new ie(e,r)}export{le as tcp};
